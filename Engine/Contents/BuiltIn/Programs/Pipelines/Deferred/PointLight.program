#include <Programs/Pipelines/Deferred/Common.program>

struct InputData { float3 Position : POSITION; };
struct TransformData { matrix4f Model; matrix4f View; matrix4f Projection; matrix4f MVP; };
struct ViewportData { float2 FrameSize; };
struct VertexOutput { float4 Position : POSITION0; float4 FragPos : FRAGMENT_POSITION; };
struct FragmentOutput {	float4 Color : TARGET0; };

texture2D PositionTexture;
texture2D NormalTexture;
texture2D AlbedoSpecTexture;
TransformData _TransformData;
ViewportData _ViewportData;
Data data;

VertexOutput VertexMain(InputData inputData)
{
	matrix4f mvp = _TransformData.MVP;
	matrix4f scaleMat = matrix4f(
		data.Radius * 2, 0, 0, 0,
		0, data.Radius * 2, 0, 0,
		0, 0, data.Radius * 2, 0,
		0, 0, 0, 1);
	mvp *= scaleMat;
	
	VertexOutput o;
	o.Position = mvp * float4(inputData.Position, 1);
	return o;
}

FragmentOutput FragmentMain(VertexOutput inputData)
{
	float2 uv = inputData.FragPos.xy / _ViewportData.FrameSize;
	float3 gPos = Sample(PositionTexture, uv).rgb;
	float distance = Length(data.WorldPosition - gPos);

	float3 result = float3(0,0,0);
	if (distance < data.Radius)
	{
		float4 gAlbedoSpec = Sample(AlbedoSpecTexture, uv);
		float3 gDiffuse = gAlbedoSpec.rgb;
		float gSpecular = gAlbedoSpec.a;

		float3 toLightDir = Normalize(data.WorldPosition - gPos);
		float3 normal = Sample(NormalTexture, uv).rgb;

		float3 diffuse = Max(Dot(normal, toLightDir), 0) * data.Color.rgb * gDiffuse * data.Strength;

		float3 viewDir = Normalize(data.ViewPosition - gPos);
		float3 halfwayDir = Normalize(toLightDir + viewDir);
		float3 specular = Pow(Max(Dot(normal, halfwayDir), 0), 16) * data.Color.rgb * gSpecular;

		float attenuation = 1 / (data.ConstantAttenuation + (data.LinearAttenuation * distance) + (data.QuadraticAttenuation * distance * distance));

		diffuse *= attenuation;
		specular *= attenuation;
		result = diffuse + specular;
	}

	FragmentOutput o;
	o.Color = float4(result, 1);
	return o;
}