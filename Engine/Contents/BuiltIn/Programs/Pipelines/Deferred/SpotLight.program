#include <Programs/Pipelines/Deferred/Common.program>

struct InputData { float3 Position : POSITION; };
struct TransformData { matrix4f Model; matrix4f View; matrix4f Projection; matrix4f MVP; };
struct ViewportData { float2 FrameSize; };
struct AutoData { matrix4f MVP; float2 FrameSize; };
struct VertexOutput { float4 Position : POSITION0; float4 FragPos : FRAGMENT_POSITION; };
struct FragmentOutput {	float4 Color : TARGET0; };

texture2D PositionTexture;
texture2D NormalTexture;
texture2D AlbedoSpecTexture;
TransformData _TransformData;
ViewportData _ViewportData;
Data data;

VertexOutput VertexMain(InputData inputData)
{
	matrix4f mvp = _TransformData.MVP;
	float coneRadius = Sin(data.OuterCutOff / 2) * (data.Radius / Cos(data.OuterCutOff / 2));
	matrix4f scaleMat = matrix4f(
		coneRadius * 2, 0, 0, 0,
		0, coneRadius * 2, 0, 0,
		0, 0, data.Radius, 0,
		0, 0, 0, 1);
	mvp *= scaleMat;

	VertexOutput o;
	o.Position = mvp * float4(inputData.Position, 1);
	return o;
}

FragmentOutput FragmentMain(VertexOutput inputData)
{
	float2 uv = inputData.FragPos.xy / _ViewportData.FrameSize;
	float3 gPos = Sample(PositionTexture, uv).rgb;
	float3 toFragDir = Normalize(gPos - data.WorldPosition);
	float theta = ACos(Dot(toFragDir, data.Direction) / Length(toFragDir) * Length(data.Direction));
	float halfOuterCutOff = data.OuterCutOff / 2;

	float3 result = float3(0,0,0);
	if (theta <= halfOuterCutOff)
	{
		float halfInnerCutOff = data.InnerCutOff / 2;
		float4 gAlbedoSpec = Sample(AlbedoSpecTexture, uv);
		float3 gDiffuse = gAlbedoSpec.rgb;
		float gSpecular = gAlbedoSpec.a;
		float3 gNormal = Sample(NormalTexture, uv).rgb;

		float3 toLightDir = Normalize(data.WorldPosition - gPos);

		float3 diffuse = Max(Dot(gNormal, toLightDir), 0) * data.Color.rgb * gDiffuse * data.Strength;

		float3 toViewDir = Normalize(data.ViewPosition - gPos);
		float3 reflectDir = Reflect(-toLightDir, gNormal);
		float specular = Pow(Max(Dot(toViewDir, reflectDir), 0), 16) * gSpecular;

		float epsilon = (halfOuterCutOff - halfInnerCutOff);
		float intensity = Clamp((halfOuterCutOff - theta) / epsilon, 0, 1);

		diffuse *= intensity;
		specular *= intensity;
		result = diffuse + specular;
	}

	FragmentOutput o;
	o.Color =  float4(result, 1);
	return o;
}